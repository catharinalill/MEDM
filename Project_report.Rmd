R_project - MEDM

---
title: "Project MEDM"
output: html_document
        #pdf_document
        
---

<!-- Press Knit, to make a html-file of the code below. This we can use while working with the report to see how it is. Because the dataset flights in pretty large it takes some time to knit the file.. 
We don´t have to compilate the code to a pdf before we are delivering it, but if you want to you might have to download a program, maybe Latex or something, I am not quite sure. I already have it so I can compilate it to a pdf when we are done with it. 
But remember if you compilate it to a pdf-file some lines can be too long and get cutted. Then you have to go in the code and adjust it. If you need a linespace you need to have 3 space in the line above. -->

<!-- In gitkranken: 
When you have edited the code, save it usual. Then open gitkranken, and you will see a blue line with 
" x file changes in working directory" and a small box "View changes" in the above right corner. Click this one. First you have to commit what you have done, i.e. click on the Project_report.html-file on the right side and press Stage File. (And don´t stage all the other files) Then make a comment on what you have changed in the file, in the bottom right corner, and press the green box "Stage files/changes to commit". 
After commiting you first have to pull what the other have done, i.e. press "Pull". If you get "pulled successfully" down in the left corner everything is okay and you can press "Push". 
If not, then we might have some merge conflict we need to fix. 
Always remember to do all these steps
1. Commit
2. Pull
3. Push

If you have edited the file, but don´t want to save it, only download what the others have done, you can press the "Stash" instead of pull and push. 
-->

```{r setup, include=FALSE}
#Have to include the files in the same folder the Rmarkdown is in.
airlines = read.csv("airlines.csv")
airports = read.csv("airports.csv")
flights = read.csv("flights.csv")

```

   
# Introduction
From a dataset of over five million flight observations from the U.S. Department of Transportation's (DOT) Bureau of Transportation Statistics, we want to use data mining techniques to select the best airline to fly on, although we only use the delay information.

Our approach is to use several classifiers to predict the delay of flights and then, with that information, find the airline which has the least amount of delay.

# Exploratory data analysis 
```{r , echo=FALSE}
#Libraries
library(ggplot2)  #for ggplot
library(class)    #for confusion matrices
library(caret)    #for knn function
library(kknn)
library(e1071)    #for naive bayes function
library(GGally)
library(corrplot)
library(DataExplorer)
library(dplyr)
library(MASS)     #for LDA
library(leaps)    #for Forward selection
library(colorspace) #for plot colors
library(dplyr) #for barplots
library(tidyverse) #for barplots

```

The dataset has 5.819.079 observations of 31 variables. Since this dataset is not prepared for classification, we must do this preparation, taking into account what we want to achieve. The goal is to choose the best airline based on the delays of theirs flights, ignoring the canceled and diverted ones. So, we will create a categorical response variable which represents the delay, and choose which variables we want to keep for the classifier.

The variables are: Year, Month, Day, Day of week, Airline, Flight number, Tail number, Origin airport, Destination airport, Schedule departure, Departure time, Departure delay,  Taxi out, Wheels off, Schedule time, Elapsed time, Air time, Distance, Wheels on, Taxi in, Scheduled arrival, Arrival time, Arrival delay, Diverted, Canceled, Cancellation reason, Air system delay, Security delay, Airtime delay, Late aircraft delay, Weather delay.

Since we are ignoring the canceled and diverted flights we removed the variables: Diverted, Canceled, Cancellation reason.
We noticed that all the flights were from the year 2015. As a result, we eliminate the variable Year, as it has no interest to this problem.

We noticed that some IATA codes for the origin and destination airports did not match any of the IATA codes from the provided list airports. In order to guarantee that the working data set had only valid IATA codes, we removed the observations that did not comply with this for the airports and airlines.

```{r , echo=TRUE}
#Create another data variable

##Remove the observations for which the flight was canceled            
handled_flights <- flights[flights$CANCELLED<1,]  
#Remove columns YEAR (2015 for all observations), CANCELLATION_REASON (since we are now dealing with flights that 
#were not canceled), CANCELLED (will have 0's since these are the flights that were not cancelled)
#and DIVERTED (will have 1's for observations where ARRIVAL DELAY = NA,so we may remove this column)
handled_flights$YEAR <- NULL
handled_flights$CANCELLATION_REASON <- NULL
handled_flights$CANCELLED <- NULL
handled_flights$DIVERTED <- NULL


#Erase the observations for which there was no information concerning the arrival delay
handled_flights<- handled_flights[is.na(handled_flights$ARRIVAL_DELAY)==FALSE,]

#Change handled_flights dataframe data types to the correct ones
#Discrete variables must be considered as FACTORs

handled_flights$MONTH <- as.factor(handled_flights$MONTH)
handled_flights$DAY <- as.factor(handled_flights$DAY)
handled_flights$DAY_OF_WEEK <- as.factor(handled_flights$DAY_OF_WEEK)
handled_flights$FLIGHT_NUMBER <- as.factor(handled_flights$FLIGHT_NUMBER)
handled_flights$SCHEDULED_DEPARTURE <- as.numeric(handled_flights$SCHEDULED_DEPARTURE)
handled_flights$DEPARTURE_TIME <- as.numeric(handled_flights$DEPARTURE_TIME)
handled_flights$DEPARTURE_DELAY <- as.numeric(handled_flights$DEPARTURE_DELAY)
handled_flights$TAXI_OUT <- as.numeric(handled_flights$TAXI_OUT)
handled_flights$WHEELS_OFF <- as.numeric(handled_flights$WHEELS_OFF)
handled_flights$SCHEDULED_TIME <- as.numeric(handled_flights$SCHEDULED_TIME)
handled_flights$ELAPSED_TIME <- as.numeric(handled_flights$ELAPSED_TIME)
handled_flights$AIR_TIME <- as.numeric(handled_flights$AIR_TIME)
handled_flights$DISTANCE <- as.numeric(handled_flights$DISTANCE)
handled_flights$WHEELS_ON <- as.numeric(handled_flights$WHEELS_ON)
handled_flights$TAXI_IN <- as.numeric(handled_flights$TAXI_IN)
handled_flights$SCHEDULED_ARRIVAL <- as.numeric(handled_flights$SCHEDULED_ARRIVAL)
handled_flights$ARRIVAL_TIME <- as.numeric(handled_flights$ARRIVAL_TIME)
handled_flights$ARRIVAL_DELAY <- as.numeric(handled_flights$ARRIVAL_DELAY)

#Create list of existent airports
airports_list <- airports$IATA_CODE

#Create list of existent airlines
airlines_list <- airlines$IATA_CODE

#Erase observations for origin_airports, destination_airports which are not contained in the data frame airports and airlines which are not contained in the data frame airlines
handled_flights<- handled_flights[handled_flights$ORIGIN_AIRPORT %in% airports_list,]
handled_flights<- handled_flights[handled_flights$DESTINATION_AIRPORT %in% airports_list,]
handled_flights<- handled_flights[handled_flights$AIRLINE %in% airlines_list,]

```


## Response variable

When taking a flight, the most common concern is to arrive on time, independently of the delay that may have occurred in the departure. So, we only took into consideration the Arrival delay to build the response variable. 

Since we want to build a classifier we need to define the response variable categories. To do this, we analyzed the delayed flights mean and median. 
(HISTOGRAM, BOXPLOT)
The results were: mean - 33.56, median - 15. So, ended up defining the following categories of DELAY:
- None: Arrival before the scheduled time or on time;
- Low: Arrival with delay between 1 and 15 minutes;
- Medium: Arrival with delay between 16 and 33 minutes;
- High: Arrival with delay greater than 33 minutes.

After defining the response variable we decided to only give to the classifier the variables that someone about to take a flight would know.


```{r , echo=TRUE}
#To define the degree of delay, we consider the median and mean value, for example, considering only the values of ARRIVAL_DELAY > 0, which represent delays
median(handled_flights$ARRIVAL_DELAY[handled_flights$ARRIVAL_DELAY>0]) #mean = 33.56 median = 15  
mean(handled_flights$ARRIVAL_DELAY[handled_flights$ARRIVAL_DELAY>0])

#We choose to consider 4 categories: 
# No delay: <= 0 min, small delay: 1-15 min, medium delay: 15-33 min, big delay: >33 min       

#Sample 100.000 of original data set 
flights_small <- sample_n(handled_flights, 100000)      #100000         #(THIS CHOICE SHOULD BE JUSTIFIED IN THE REPORT!)

#Define delay as a FACTOR (category)
flights_small$DELAY <- as.factor( ifelse(flights_small$ARRIVAL_DELAY < 1,flights_small$DELAY <- "None",
              ifelse(flights_small$ARRIVAL_DELAY <16,flights_small$DELAY <- "Low", 
                     ifelse(flights_small$ARRIVAL_DELAY <34,flights_small$DELAY <- "Medium", flights_small$DELAY <- "High"))) )

#Barplot of the delays per Airline  
barplot(table(flights_small$DELAY, flights_small$AIRLINE), main="Car Distribution by Gears and VS",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(counts), beside=TRUE) 
#WANT TO CHANGE THE ORDER OF THE BARS TO: None, Low, Medium, High (maintaining the colors)


#Since our objective is to predict the delay of a flight, we might walk a mile in someone else's shoes, this time, in the shoes of someone who is about to take a flight.
#So, we must give to the classifier, only the variables corresponding to subjects known a priori: scheduled departure, etc.


#Maintain a priori columns and remove a posteriori columns
flights_to_predict <- flights_small[,]
flights_to_predict$DEPARTURE_TIME <- NULL
flights_to_predict$DEPARTURE_DELAY <- NULL
flights_to_predict$TAXI_OUT <- NULL                             
flights_to_predict$WHEELS_OFF <- NULL
flights_to_predict$ELAPSED_TIME <- NULL
flights_to_predict$AIR_TIME <- NULL
flights_to_predict$DISTANCE <- NULL    
flights_to_predict$WHEELS_ON <- NULL
flights_to_predict$TAXI_IN <- NULL
flights_to_predict$ARRIVAL_TIME <- NULL
flights_to_predict$ARRIVAL_DELAY <- NULL
flights_to_predict$AIR_SYSTEM_DELAY <- NULL
flights_to_predict$SECURITY_DELAY <- NULL
flights_to_predict$AIRLINE_DELAY <- NULL
flights_to_predict$LATE_AIRCRAFT_DELAY <- NULL
flights_to_predict$WEATHER_DELAY <- NULL

```



## Final data set

After exploring and processing the data according to our goal, the classification problem will have 11 features, where 8 are categorical: Month, Day, Day of week, Airline, Flight number, Tail number, Origin airport, Destination airport; and 3 are continuous: Schedule departure, Schedule time and Schedule arrival

We still want to explain or add the following:
- size does matter (explained - possible plots to show distributions)
- chart airlines, per airline - delays
- maybe consider report charts (distances, distributions, qqplot)

```{r , echo=TRUE}
#Find the percentages of each airline
n = dim(handled_flights)[1]
counts <- table(handled_flights$AIRLINE)
percentage <- counts/n
percentage

#Find the percentages of each airline in small dataset
n2 = dim(flights_small)[1]
counts2 <- table(flights_small$AIRLINE)
percentage2 <- counts2/n2
percentage2
#Comment that we see that these percentages is the same so this is okay to do

#Count by airline how many flights are delayed in handled_flights
handled_flightsdelayed<- handled_flights[handled_flights$ARRIVAL_DELAY>0,]
counts3 <- table(handled_flightsdelayed$AIRLINE)
percentdelayedbyairline <- counts3/counts

#Count by airline how many flights are delayed in flights_small
flights_smalldelayed<- flights_small[flights_small$ARRIVAL_DELAY>0,]
counts4 <- table(flights_smalldelayed$AIRLINE)
percentdelayedbyairline2 <- counts4/counts2

percentdelayedbyairline
percentdelayedbyairline2 

#Check if the variable distributions are maintained after sampling - YES!
# create_report(flights_small, output_file = 'report_flights_small.html')
# create_report(handled_flights, output_file = 'report_handled_flights.html')


#Check correlation
plot_correlation((flights_to_predict[, 1:11]), type = "continuous")
#Maybe comment in the report that this seems okay!

```




```{r , echo=TRUE}

#Correlation
plot_correlation((flights_small[, 1:22]), type = "continuous")

#Looking at the correlation plot we remove variable with correlation coefficient larger than 0.9
handled_flights_small = flights_small[,]
handled_flights_small$DEPARTURE_DELAY <- NULL
handled_flights_small$WHEELS_ON <- NULL
handled_flights_small$WHEELS_OFF <- NULL
handled_flights_small$SCHEDULED_ARRIVAL <- NULL
handled_flights_small$SCHEDULED_DEPARTURE <- NULL
handled_flights_small$ELAPSED_TIME <- NULL
handled_flights_small$AIR_TIME <- NULL
handled_flights_small$DISTANCE <- NULL

plot_correlation((handled_flights_small[, 1:14]), type = "continuous")

#Categorical variables
plot_bar(handled_flights_small)

#SHOULD WE CONSIDER THE CATEGORICAL VARIABLES HERE??

################### Another approach of variable selection #########################
#Try Forward Selection
regfit.full = regsubsets(DELAY~.,data = flights_small,method = "forward")
reg.summary = summary(regfit.full)

#Plot adjusted R^2, C_p and BIC for all the models at once
par(mfrow =c(3,2))

plot(reg.summary$adjr2,xlab="Number of Variables", ylab = "Adjusted RSq", type = "1")
adjr2_max = which.max(reg.summary$adjr2)
points(adjr2_max, reg.summary$adjr2[adjr2_max], col = "red", cex = 2, pch = 20)

plot(reg.summary$bic,xlab="Number of Variables", ylab = "BIC", type = "1")
bic_min = which.min(reg.summary$bic)
points(bic_min, reg.summary$bic[bic_min], col = "red", cex = 2, pch = 20)

plot(reg.summary$cp,xlab="Number of Variables", ylab = "Cp", type = "1")
cp_min = which.min(reg.summary$cp)
points(cp_min, reg.summary$cp[cp_min], col = "red", cex = 2, pch = 20)

#From this we can choose the "best" model and use this subset of variables to do the classification



```



# PART 2: SOLVE CLASSIFICATION PROBLEM

 <!-- Solve your classification problem.  Consider several classification methods and discuss  how  can  they  contribute  for  the  solution  of  your  problem.   Include in your discussion topics such as the options that you have made in building each  classifier;  interpretation  of  results;  validation  of  the  methods  used  and possible assumptions;  advantages and disadvantages of each alternative;  etc. Have  in  mind  that  some  of  the  explanatory  variables  may  be  irrelevant  to the  classification problem and that  you may need to  do  some  preprocessing methodologies of your data set e.g.  dimensionality reduction techniques.-->

## Hold Out Method
```{r , echo=TRUE}
#Split sample in train (70%), validation (15%) and test (15%)
#Train: create the model
#Validation: choose parameters for classifiers
#Test: evaluate the fit of the classifier and compare it with the others

set.seed(0)   # To fix the random process at splitting data
num_obs <- dim(flights_to_predict)[1]
index_list <- c(1:num_obs)
train_index <- sample(index_list, num_obs*0.7)
test_valid_index <- setdiff(index_list, train_index)
test_index <- sample(test_valid_index, length(test_valid_index)*0.5)
valid_index <- setdiff(test_valid_index, test_index)

train_data <- flights_to_predict[train_index,]
#train_data$DELAY <- NULL     

train_data_y <- (flights_to_predict[train_index,])$DELAY

valid_data <- flights_to_predict[valid_index,]
#valid_data$DELAY <- NULL

valid_data_y <- (flights_to_predict[valid_index,])$DELAY

test_data <- flights_to_predict[test_index,]
#test_data$DELAY <- NULL    

test_data_y <- (flights_to_predict[test_index,])$DELAY

#Checking distribution in original and partitioned data  
# prop.table(table(train_data_y)) * 100 # at training set 
# prop.table(table(test_data_y)) * 100  # at testing set
# prop.table(table(valid_data_y)) * 100  # at validation set
# prop.table(table(flights_to_predict$DELAY)) * 100  # at original dataset
#THIS SEEMS FINE!


```


## KNN

```{r , echo=FALSE}
#We will use Hold Out Method to partition the sample in train, validation and test data

# set.seed(0) 
# Spliting data as training and test set using createDataPartition() function from caret
#indxTrain <- createDataPartition(y = handled_flights_small[,15], p = 0.8,list = FALSE)
#train.data <- handled_flights_small[indxTrain,]
#test.data <- handled_flights_small[-indxTrain,]

co = rainbow_hcl(3)

#Make model
ks = 1:10 #Choose K from 1 to 10
classification_errors = sapply(ks,function(k) {
  pred.knn <- kknn(formula = formula(train_data[,12]~.), train = train_data, test = valid_data, k = k, distance = 1)
  fit <- fitted(pred.knn)
  mean(valid_data[,12] != fit)   #I think this is the accuracy, but it should be the classification variables
})
classification_errors

#Choose the model that has the lowest classification error, use this K
which.min(classification_errors) #The best k is 7

plot(ks, classification_errors, type="o", pch = 16, ylim = c(0, 1), col = co[2],
     xlab = "Number of neighbors", ylab="Misclassification error")

k_optimal = 7

pred.knn.m1 <- kknn(formula = formula(train_data[,12]~.), train = train_data, test = test_data, k = k_optimal, distance = 1)
fit.m1<-fitted(pred.knn.m1)
fit.m1

#Classification error
mean(test_data[,12] != fit.m1)

#Accuracy
mean(test_data[,12] == fit.m1)

#Confusion matrix
table(test_data[,12] , fit.m1)

#If predicted value is 0 (i.e. not delayed), find the airline and make a count
#Find which airlines that are delayed and not
no_delay = test_data[test_data$DELAY == 0,]
small_delay = test_data[test_data$DELAY == 1,]
medium_delay =  test_data[test_data$DELAY == 2,]
big_delay = test_data[test_data$DELAY == 3,]

count_0 <- table(no_delay$AIRLINES)
count_1 <- table(small_delay$AIRLINES)
count_2 <- table(medium_delay$AIRLINES)
count_3 <- table(big_delay$AIRLINES)


```
## Naive Bayes method

```{r , echo=TRUE}

modelNB <- naiveBayes(formula = formula(train_data[,12]~.), data = train_data)
predictNB <- predict(modelNB, test_data)
table(predictNB, test_data_y)

#Compute Naive Bayes error
mean(test_data[,12] != predictNB)

#Compute Naive Bayes accuracy
mean(test_data[,12] == predictNB)

```

## Decision Tree
```{r , echo=TRUE}



```

# Learning/Limitations/Future work

 <!-- Imagine you are going to meet the researcher who contacted you.  Report to him/her what you have learned about the problem.  Discuss limitations of the analysis you have done and provide suggestions for future work.-->


```{r , echo=TRUE}


```

