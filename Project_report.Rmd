R_project - MEDM

---
title: "Project MEDM"
output: html_document
        #pdf_document
        
---

<!-- Press Knit, to make a html-file of the code below. This we can use while working with the report to see how it is. Because the dataset flights in pretty large it takes some time to knit the file.. 
We don´t have to compilate the code to a pdf before we are delivering it, but if you want to you might have to download a program, maybe Latex or something, I am not quite sure. I already have it so I can compilate it to a pdf when we are done with it. 
But remember if you compilate it to a pdf-file some lines can be too long and get cutted. Then you have to go in the code and adjust it. If you need a linespace you need to have 3 space in the line above. -->

<!-- In gitkranken: 
When you have edited the code, save it usual. Then open gitkranken, and you will see a blue line with 
" x file changes in working directory" and a small box "View changes" in the above right corner. Click this one. First you have to commit what you have done, i.e. click on the Project_report.html-file on the right side and press Stage File. (And don´t stage all the other files) Then make a comment on what you have changed in the file, in the bottom right corner, and press the green box "Stage files/changes to commit". 
After commiting you first have to pull what the other have done, i.e. press "Pull". If you get "pulled successfully" down in the left corner everything is okay and you can press "Push". 
If not, then we might have some merge conflict we need to fix. 
Always remember to do all these steps
1. Commit
2. Pull
3. Push

If you have edited the file, but don´t want to save it, only download what the others have done, you can press the "Stash" instead of pull and push. 
-->

```{r setup, include=FALSE}
#Have to include the files in the same folder the Rmarkdown is in.
airlines = read.csv("airlines.csv")
airports = read.csv("airports.csv")
flights = read.csv("flights.csv")

```

   
# Introduction


# Exploratory data analysis 
```{r , echo=FALSE}
#Libraries
library(ggplot2)       #for ggplot
library(class)         #for confusion matrices
library(caret)         #for knn function
library(kknn)
library(e1071)         #for naive bayes function
library(GGally)
library(corrplot)
library(DataExplorer)
library(dplyr)
library(MASS)          #for LDA
library(nnet)          #for LDA
library(leaps)         #for Forward selection
library(colorspace)    #for plot colors
library(dplyr)         #for barplots
library(tidyverse)     #for barplots
# library(StatMatch)     #for knngow function
# library(dprep)        #for knngow function
library(broom)
library(rpart)        #for fitting tree
library(rpart.plot)   #for plotting tree
library(leaflet)  #for map plots
```


```{r , echo=TRUE}
#Create another data set

##Remove the observations for which the flight was cancelled            
handled_flights <- flights[flights$CANCELLED<1,]  
#Remove columns YEAR (2015 for all observations), CANCELLATION_REASON (since we are now dealing with flights that were not canceled), CANCELLED (will have 0's since these are the flights that were not cancelled) and DIVERTED (will have 1's for observations where ARRIVAL DELAY = NA,so we may remove this column)
handled_flights$YEAR <- NULL
handled_flights$CANCELLATION_REASON <- NULL
handled_flights$CANCELLED <- NULL
handled_flights$DIVERTED <- NULL


#Erase the observations for which there was no information concerning the arrival delay
handled_flights<- handled_flights[is.na(handled_flights$ARRIVAL_DELAY)==FALSE,]

#Change handled_flights dataframe data types to the correct ones
#Discrete variables must be considered as FACTORs
handled_flights$MONTH <- as.factor(handled_flights$MONTH)
handled_flights$DAY <- as.factor(handled_flights$DAY)
handled_flights$DAY_OF_WEEK <- as.factor(handled_flights$DAY_OF_WEEK)
handled_flights$FLIGHT_NUMBER <- as.factor(handled_flights$FLIGHT_NUMBER)
handled_flights$SCHEDULED_DEPARTURE <- as.numeric(handled_flights$SCHEDULED_DEPARTURE)
handled_flights$DEPARTURE_TIME <- as.numeric(handled_flights$DEPARTURE_TIME)
handled_flights$DEPARTURE_DELAY <- as.numeric(handled_flights$DEPARTURE_DELAY)
handled_flights$TAXI_OUT <- as.numeric(handled_flights$TAXI_OUT)
handled_flights$WHEELS_OFF <- as.numeric(handled_flights$WHEELS_OFF)
handled_flights$SCHEDULED_TIME <- as.numeric(handled_flights$SCHEDULED_TIME)
handled_flights$ELAPSED_TIME <- as.numeric(handled_flights$ELAPSED_TIME)
handled_flights$AIR_TIME <- as.numeric(handled_flights$AIR_TIME)
handled_flights$DISTANCE <- as.numeric(handled_flights$DISTANCE)
handled_flights$WHEELS_ON <- as.numeric(handled_flights$WHEELS_ON)
handled_flights$TAXI_IN <- as.numeric(handled_flights$TAXI_IN)
handled_flights$SCHEDULED_ARRIVAL <- as.numeric(handled_flights$SCHEDULED_ARRIVAL)
handled_flights$ARRIVAL_TIME <- as.numeric(handled_flights$ARRIVAL_TIME)
handled_flights$ARRIVAL_DELAY <- as.numeric(handled_flights$ARRIVAL_DELAY)

#Create list of existent airports
airports_list <- airports$IATA_CODE

#Create list of existent airlines
airlines_list <- airlines$IATA_CODE

#Erase observations for origin_airports, destination_airports which are not contained in the data frame airports and airlines which are not contained in the data frame airlines
handled_flights<- handled_flights[handled_flights$ORIGIN_AIRPORT %in% airports_list,]
handled_flights<- handled_flights[handled_flights$DESTINATION_AIRPORT %in% airports_list,]
handled_flights<- handled_flights[handled_flights$AIRLINE %in% airlines_list,]

```


## Response variable

```{r , echo=TRUE}
#To define the degree of delay, we consider the median and mean value, for example, considering only the values of ARRIVAL_DELAY > 0, which represent delays
# median(handled_flights$ARRIVAL_DELAY[handled_flights$ARRIVAL_DELAY>0]) #mean = 33.56 median = 15  
# mean(handled_flights$ARRIVAL_DELAY[handled_flights$ARRIVAL_DELAY>0])


flights_small <- sample_n(handled_flights, 100000)     

#CONSIDER 4 CATEGORIES FOR RESPONSE
#To define the degree of delay, we consider the median and mean value, for example, considering only the values of ARRIVAL_DELAY > 0, which represent delays
# median(handled_flights$ARRIVAL_DELAY[handled_flights$ARRIVAL_DELAY>0]) #mean = 33.56 median = 15  
# mean(handled_flights$ARRIVAL_DELAY[handled_flights$ARRIVAL_DELAY>0])

# flights_small$DELAY <- as.factor( ifelse(flights_small$ARRIVAL_DELAY < 1,flights_small$DELAY <- "None", ifelse(flights_small$ARRIVAL_DELAY <16,flights_small$DELAY <- "Low", ifelse(flights_small$ARRIVAL_DELAY <34,flights_small$DELAY <- "Medium", flights_small$DELAY <- "High"))) )


#Define only 2 categories fore response variable(None, Delayed) 
flights_small$DELAY <- as.factor( ifelse(flights_small$ARRIVAL_DELAY < 1,flights_small$DELAY <- "None", flights_small$DELAY <- "Delayed"))


#Check response variable categories distribution in flights_small
counts_nodelay <- as.matrix(table(flights_small$DELAY=="None")) #The categories are not balanced - chose "manually" the observations so we get what desired, compromising the airline balance?
counts_nodelay <- counts_nodelay/colSums(counts_nodelay)



#Since our objective is to predict the delay of a flight, we might walk a mile in someone else's shoes, this time, in the shoes of someone who is about to take a flight.
#So, we must give to the classifier, only the variables corresponding to subjects known a priori: scheduled departure, etc.



#Maintain a priori columns and remove a posteriori columns
flights_to_predict <- flights_small[,]
flights_to_predict$DEPARTURE_TIME <- NULL
flights_to_predict$DEPARTURE_DELAY <- NULL
flights_to_predict$TAXI_OUT <- NULL                             
flights_to_predict$WHEELS_OFF <- NULL
flights_to_predict$ELAPSED_TIME <- NULL
flights_to_predict$AIR_TIME <- NULL
flights_to_predict$DISTANCE <- NULL    
flights_to_predict$WHEELS_ON <- NULL
flights_to_predict$TAXI_IN <- NULL
flights_to_predict$ARRIVAL_TIME <- NULL
flights_to_predict$ARRIVAL_DELAY <- NULL
flights_to_predict$AIR_SYSTEM_DELAY <- NULL
flights_to_predict$SECURITY_DELAY <- NULL
flights_to_predict$AIRLINE_DELAY <- NULL
flights_to_predict$LATE_AIRCRAFT_DELAY <- NULL
flights_to_predict$WEATHER_DELAY <- NULL

#Remove flight number and tail number variables since they have various levels - show that there is no influence on the categories (PLots, Histograms, etc)
flights_to_predict$FLIGHT_NUMBER <- NULL
flights_to_predict$TAIL_NUMBER <- NULL

#Separate data into the 4 categories and report results
#nodelay <- flights_to_predict[flights_to_predict$DELAY=="None",]
#lowdelay <- flights_to_predict[flights_to_predict$DELAY=='Low',]
#mediumdelay <- flights_to_predict[flights_to_predict$DELAY=='Medium',]
#highdelay <- flights_to_predict[flights_to_predict$DELAY=='High',]

# create_report(nodelay, output_file = 'nodelay.html')
# create_report(lowdelay, output_file = 'lowdelay.html')
# create_report(mediumdelay, output_file = 'mediumdelay.html')
# create_report(highdelay, output_file = 'highdelay.html')

#Temporary remove this variables 
# flights_to_predict$MONTH <- NULL
# flights_to_predict$DAY <- NULL
# flights_to_predict$DAY_OF_WEEK <- NULL
# flights_to_predict$FLIGHT_NUMBER <- NULL
# flights_to_predict$TAIL_NUMBER <- NULL
# flights_to_predict$ORIGIN_AIRPORT <- NULL
# flights_to_predict$DESTINATION_AIRPORT <- NULL
# flights_to_predict$SCHEDULED_DEPARTURE <- NULL
# flights_to_predict$SCHEDULED_ARRIVAL <- NULL
# flights_to_predict$SCHEDULED_TIME <- NULL
# flights_to_predict$AIRLINE <- NULL

```

## Exploratory data analysis Plots and Graphs and Histograms
```{r , echo=TRUE}
#FOR handled_flights (can be seen as the "original" data set, since it did not suffer undersampling)

#Number of delayed and not delayed flights
handled_flights$DELAY <- as.factor( ifelse(handled_flights$ARRIVAL_DELAY < 1,handled_flights$DELAY <- "None", handled_flights$DELAY <- "Delayed"))

handled_flights_delayed <- dim(handled_flights[handled_flights$DELAY=='Delayed',])[1]
handled_flights_notdelayed <- dim(handled_flights[handled_flights$DELAY=='None',])[1]

#Histogram with Number of delayed and not delayed flights
barplot(table(handled_flights$DELAY), main="Frequencies of response variable categories",
  xlab="Categories", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY)), beside=TRUE)

#Barplot of the delays per Month - original data set
barplot(table(handled_flights$DELAY, handled_flights$MONTH), main="Categories of delay by Month - Original data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY, handled_flights$MONTH)), beside=TRUE)

#Barplot of the delays per Day - original data set
barplot(table(handled_flights$DELAY, handled_flights$DAY), main="Categories of delay by Day - Original data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY, handled_flights$DAY)), beside=TRUE)

#Barplot of the delays per Day Of Week - original data set
barplot(table(handled_flights$DELAY, handled_flights$DAY_OF_WEEK), main="Categories of delay by Day Of Week - Original data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY, handled_flights$DAY_OF_WEEK)), beside=TRUE)

#Barplot of the delays per Airline - original data set
barplot(table(handled_flights$DELAY, handled_flights$AIRLINE), main="Categories of delay by Airline - Original data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY, handled_flights$AIRLINE)), beside=TRUE)



#FOR flights_to_predict

#Barplot of the delays per Month - final data set
barplot(table(flights_to_predict$DELAY, flights_to_predict$MONTH), main="Categories of delay by Month - Final data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY, flights_to_predict$MONTH)), beside=TRUE)

#Barplot of the delays per Day - final data set
barplot(table(flights_to_predict$DELAY, flights_to_predict$DAY), main="Categories of delay by Day - Final data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY, flights_to_predict$DAY)), beside=TRUE)

#Barplot of the delays per Day Of Week - final data set
barplot(table(flights_to_predict$DELAY, flights_to_predict$DAY_OF_WEEK), main="Categories of delay by Day Of Week - Final data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY, flights_to_predict$DAY_OF_WEEK)), beside=TRUE)

#Barplot of the delays per Airline - final data set
barplot(table(flights_to_predict$DELAY, flights_to_predict$AIRLINE), main="Categories of delay by Airline - Final data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY, flights_to_predict$AIRLINE)), beside=TRUE)




```


## Final data set

```{r , echo=TRUE}
#Find the percentages of each airline
n = dim(handled_flights)[1]
counts <- table(handled_flights$AIRLINE)
percentage <- counts/n
percentage

#Find the percentages of each airline in small dataset
n2 = dim(flights_small)[1]
counts2 <- table(flights_small$AIRLINE)
percentage2 <- counts2/n2
percentage2
#Comment that we see that these percentages is the same so this is okay to do

#Count by airline how many flights are delayed in handled_flights
handled_flightsdelayed<- handled_flights[handled_flights$ARRIVAL_DELAY>0,]
counts3 <- table(handled_flightsdelayed$AIRLINE)
percentdelayedbyairline <- counts3/counts

#Count by airline how many flights are delayed in flights_small
flights_smalldelayed<- flights_small[flights_small$ARRIVAL_DELAY>0,]
counts4 <- table(flights_smalldelayed$AIRLINE)
percentdelayedbyairline2 <- counts4/counts2

percentdelayedbyairline
percentdelayedbyairline2 

#Check if the variable distributions are maintained after sampling- NO! BECAUSE WE MUST MANTAIN THE BALANCE BETWEEN CLASSES
# create_report(flights_small, output_file = 'report_flights_small.html')
# create_report(handled_flights, output_file = 'report_handled_flights.html')


#Check correlation
plot_correlation((flights_to_predict[, 1:10]), type = "continuous")
#Maybe comment in the report that this seems okay!
#WE CAN SHOW THIS PLOT JUST FOR THE 3 CONTINUOUS VARIABLES

```

   

# PART 2: SOLVE CLASSIFICATION PROBLEM

 <!-- Solve your classification problem.  Consider several classification methods and discuss  how  can  they  contribute  for  the  solution  of  your  problem.   Include in your discussion topics such as the options that you have made in building each  classifier;  interpretation  of  results;  validation  of  the  methods  used  and possible assumptions;  advantages and disadvantages of each alternative;  etc. Have  in  mind  that  some  of  the  explanatory  variables  may  be  irrelevant  to the  classification problem and that  you may need to  do  some  preprocessing methodologies of your data set e.g.  dimensionality reduction techniques.-->

## Hold Out Method
```{r , echo=TRUE}
#Split sample in train (70%), validation (15%) and test (15%)
#Train: create the model
#Validation: choose parameters for classifiers
#Test: evaluate the fit of the classifier and compare it with the others

set.seed(0)   # To fix the random process at splitting data
num_obs <- dim(flights_to_predict)[1]
index_list <- c(1:num_obs)
train_index <- sample(index_list, num_obs*0.7)
test_valid_index <- setdiff(index_list, train_index)
test_index <- sample(test_valid_index, length(test_valid_index)*0.5)
valid_index <- setdiff(test_valid_index, test_index)

train_data <- flights_to_predict[train_index,]
train_data_x <- flights_to_predict[train_index,]
train_data_x$DELAY <- NULL 
train_data_y <- (flights_to_predict[train_index,])$DELAY


valid_data <- flights_to_predict[valid_index,]
valid_data_x <- flights_to_predict[valid_index,]
valid_data_x$DELAY <- NULL 
valid_data_y <- (flights_to_predict[valid_index,])$DELAY


test_data <- flights_to_predict[test_index,]
test_data_x <- flights_to_predict[test_index,]
test_data_x$DELAY <- NULL 
test_data_y <- (flights_to_predict[test_index,])$DELAY

#Checking distribution in original and partitioned data  
# prop.table(table(train_data_y)) * 100 # at training set 
# prop.table(table(test_data_y)) * 100  # at testing set
# prop.table(table(valid_data_y)) * 100  # at validation set
# prop.table(table(flights_to_predict$DELAY)) * 100  # at original dataset
#THIS SEEMS FINE!


```

## Naive Bayes method

```{r , echo=TRUE}

modelNB <- naiveBayes(formula = formula(train_data_y~.), data = train_data)
predictNB <- predict(modelNB, test_data_x)

#Confusion matrix
table(predictNB, test_data_y)

#Compute NB error
mean(test_data_y != predictNB)

#Compute NB accuracy
mean(test_data_y == predictNB)


#SENSITIVE MEASURES

#Sensitivity: proportion of positive results out of the number of samples which were actually positive.
senseNB <- sensitivity(predictNB, test_data_y, positive = "None")
#Specificity: proportion of negative results out of the number of samples which were actually negative.
specNB <- specificity(predictNB, test_data_y, negative = "Delayed")

#Precision/Positive Predictive Value: percent of predicted positives that are actually positive.
posPredNB <- posPredValue(predictNB, test_data_y, positive = "None")
#Negative Predictive Value: percent of negative positives that are actually negative.
negPredNB <- negPredValue(predictNB, test_data_y, negative = "Delayed")

#NOTE: when there are no positive/negative results, Nan is returned. In this case, there are no negatives, which I do not understand


#BACKWARD PROBLEM: FIND THE AIRLINE

#Find the best airline using the histogram
tableNB <- cbind(test_data_x, predictNB)


#Barplot of the delays per Airline  
barplot(table(tableNB$predictNB, tableNB$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "green"), args.legend = list(x="topleft"),
  legend = rownames(table(tableNB$predictNB, tableNB$AIRLINE)), beside=TRUE)

#Get the percentages of delayed and not delayed for Airline
countdelayNB <- as.matrix(table(tableNB$predictNB, tableNB$AIRLINE))
countdelayNB <- sweep(countdelayNB, 2, colSums(countdelayNB), FUN = '/')

colnames(countdelayNB) = c("AA","AS", "B6","DL","EV","F9","HA","MQ","NK","OO","UA","US","VX","WN") 
rownames(countdelayNB) = c("Delayed", "None")

#Get the most and least delayed Airline
mostdelayedNB <- colnames(countdelayNB)[which.is.max(countdelayNB[1,])] 
mostdelayedNB      #Airline which had the higher value of delay

leastdelayedNB <- colnames(countdelayNB)[which.is.max(countdelayNB[2,])] 
leastdelayedNB      #Airline which had the lower value of delay

#See sorted list of delayed and non delayed
mostdelayed_sortNB <- sort(countdelayNB[1,], decreasing = TRUE) #Higher percentage means high delay
leastdelayed_sortNB <- sort(countdelayNB[2,], decreasing = TRUE) #Higher percentage means low delay


```


## Decision Tree
```{r , echo=TRUE}

modelTREE <- rpart(formula = formula(train_data_y~.), data = train_data_x, method = "class", parms = list(split ="information")) #instead of information, we may use "gini"
#We may consider the splitting using Gini criterion or Information criterion: #https://en.wikipedia.org/wiki/Decision_tree_learning#Information_gain
#Accuracy is the same, but the most delayed and least delayed airlines are different for each case

summary(modelTREE)
rpart.plot(modelTREE)

predictTREE <- predict(modelTREE, test_data_x, type = "class")

#Confusion matrix
table(predictTREE, test_data_y)

#Compute the TREE error
mean(test_data_y != predictTREE)

#Compute TREE accuracy
mean(test_data_y == predictTREE)


#SENSITIVE MEASURES

#Sensitivity: proportion of positive results out of the number of samples which were actually positive.
senseTREE <- sensitivity(predictTREE, test_data_y, positive = "None")
#Specificity: proportion of negative results out of the number of samples which were actually negative.
specTREE <- specificity(predictTREE, test_data_y, negative = "Delayed")

#Precision/Positive Predictive Value: percent of predicted positives that are actually positive.
posPredTREE <- posPredValue(predictTREE, test_data_y, positive = "None")
#Negative Predictive Value: percent of negative positives that are actually negative.
negPredTREE <- negPredValue(predictTREE, test_data_y, negative = "Delayed")

#NOTE: when there are no positive/negative results, Nan is returned. In this case, there are no negatives, which I do not understand


#BACKWARD PROBLEM: FIND THE AIRLINE

#Find the best airline using the histogram
tableTREE <- cbind(test_data_x, predictTREE)

#Barplot of the delays per Airline  
barplot(table(tableTREE$predictTREE, tableTREE$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "blue"), args.legend = list(x="topleft"),
  legend = rownames(table(tableTREE$predictTREE, tableTREE$AIRLINE)), beside=TRUE)


#Get the percentages of delayed and not delayed for Airline
countdelayTREE <- as.matrix(table(tableTREE$predictTREE, tableTREE$AIRLINE))
countdelayTREE <- sweep(countdelayTREE, 2, colSums(countdelayTREE), FUN = '/')
colnames(countdelayTREE) = c("AA","AS", "B6","DL","EV","F9","HA","MQ","NK","OO","UA","US","VX","WN") 
rownames(countdelayTREE) = c("Delayed", "None")

#Get the most delayed Airline
mostdelayedTREE <- colnames(countdelayTREE)[which.is.max(countdelayTREE[1,])] #Airline which had the higher value of delay
leastdelayedTREE <- colnames(countdelayTREE)[which.is.max(countdelayTREE[2,])] #Airline which had the lower value of delay

#See sorted list of delayed and non delayed
mostdelayed_sortTREE <- sort(countdelayTREE[1,], decreasing = TRUE) #Higher percentage means high delay
leastdelayed_sortTREE <- sort(countdelayTREE[2,], decreasing = TRUE) #Higher percentage means low delay

mostdelayedTREE
leastdelayedTREE
```
One advantage with the classification tree is that they are more flexible than linear methods. 

## Support Vector Classifier
```{r, echo=TRUE}
library(e1071)
modelSVM = svm(train_data_y~., data = train_data_x, kernel = "linear", cost = 10)

predictSVM <- predict(modelSVM, test_data)

#Confusion matrix
table(predictSVM, test_data_y)

#Compute the TREE error
mean(test_data_y != predictSVM)

#Compute TREE accuracy
mean(test_data_y == predictSVM) 
  
#Find the best airline using the histogram
tableSVM <- cbind(test_data_x, predictSVM)


#Barplot of the delays per Airline  
barplot(table(tableSVM$predictSVM, tableSVM$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "blue"), args.legend = list(x="topleft"),
  legend = rownames(table(tableSVM$predictSVM, tableSVM$AIRLINE)), beside=TRUE)

#Get the percentages of delayed and not delayed for Airline
countdelaySVM <- as.matrix(table(tableSVM$predictSVM, tableSVM$AIRLINE))
countdelaySVM <- sweep(countdelaySVM, 2, colSums(countdelaySVM), FUN = '/')

colnames(countdelaySVM) = c("AA","AS", "B6","DL","EV","F9","HA","MQ","NK","OO","UA","US","VX","WN") 
rownames(countdelaySVM) = c("Delayed", "None")

#Get the most and least delayed Airline
mostdelayedSVM <- colnames(countdelaySVM)[which.is.max(countdelaySVM[1,])] 
mostdelayedSVM      #Airline which had the higher value of delay

leastdelayedSVM <- colnames(countdelaySVM)[which.is.max(countdelaySVM[2,])] 
leastdelayedSVM      #Airline which had the lower value of delay

#See sorted list of delayed and non delayed
mostdelayed_sortSVM <- sort(countdelaySVM[1,], decreasing = TRUE) #Higher percentage means high delay
leastdelayed_sortSVM <- sort(countdelaySVM[2,], decreasing = TRUE) #Higher percentage means low delay

mostdelayed_sortSVM
leastdelayed_sortSVM
```

## Logistic Regression - problems with the presence of categories for all variables in train and test sets
```{r, echo=TRUE}
train_data_logreg = train_data[,]
train_data_logreg$ORIGIN_AIRPORT <- NULL
train_data_logreg$DESTINATION_AIRPORT <- NULL
train_data_logreg$MONTH <- NULL
train_data_logreg$DAY <- NULL
train_data_logreg$DAY_OF_WEEK <- NULL

test_data_logreg = test_data[,]
test_data_logreg$ORIGIN_AIRPORT <- NULL
test_data_logreg$DESTINATION_AIRPORT <- NULL
test_data_logreg$MONTH <- NULL
test_data_logreg$DAY <- NULL
test_data_logreg$DAY_OF_WEEK <- NULL

delay = vector(length = length(train_data_y))
delay = ifelse(train_data_y == "None",0,1)
#We use family = binomial since our response is of type factor

#Fit model
modelLR <- glm(formula = formula(delay~.), data = train_data, family = "binomial", control = list(maxit = 5000))

coef(modelLR)
modelLR

predictLR <- predict(modelLR, test_data_logreg)
predictLR

# n = obs
#round(n*0.15)

DELAY <- vector(mode = "character",length = 1500)
for (i in 1:1500) {
DELAY[i] = ifelse(predictLR[i] < 30, "Delayed", "None")
}

#Confusion matrix
table(DELAY, test_data_y)

#Compute the TREE error
mean(test_data_y != predictLR)

#Compute TREE accuracy
mean(test_data_y == predictLR)


#Find the best airline using the histogram
tableLR <- cbind(test_data_x, predictLR)

#Barplot of the delays per Airline  
barplot(table(tableLR$predictLR, tableLR$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(table(tableLR$predictLR, tableLR$AIRLINE)), beside=TRUE)
#Remember to adjust number of colours to number of categories in the response variable

```


## Probably not gonna be used

### Multinomial Logistic regression - Should be considered, for instance, if we mantain 4 categories

<!--We use Multinomial logistic regression since we have 4 categories: None, Low, Medium, High-->
   
```{r , echo=TRUE}
#Fit model
modelMLR <- multinom(formula = formula(train_data_y~.), data= train_data)
predictMLR <- predict(modelMLR, test_data_x)

#Confusion matrix
table(predictMLR, test_data_y)

#Compute MLR error
mean(test_data_y != predictMLR)

#Compute MLR accuracy
mean(test_data_y == predictMLR)


#Find the best airline using the histogram
tableMLR <- cbind(test_data_x, predictMLR)

#Barplot of the delays per Airline  
barplot(table(tableMLR$predictMLR, tableMLR$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(table(tableMLR$predictMLR, tableMLR$AIRLINE)), beside=TRUE)
#Remember to adjust number of colours to number of categories in the response variable

```

## KNN - not able to consider factor and continuous variables simultaneously

```{r , echo=FALSE}
#We will use Hold Out Method to partition the sample in train, validation and test data

co = rainbow_hcl(3)

#Make model
ks = 1:10 #Choose K from 1 to 10
classification_errors = sapply(ks,function(k) {
  pred.knn <- kknn(formula = formula(train_data_y~.), train = train_data, test = valid_data, k = k, distance = 1)
  fit <- fitted(pred.knn)
  mean(valid_data_y != fit)   #I think this is the accuracy, but it should be the classification variables
})

####ANother attempt at calculating class_error############################ THINK WE DO NOT NEED THIS

# knngow_func <- function (train,valid,k) {
#   p=dim(train)[2]
#   ntest=dim(valid)[1]
#   ntrain=dim(train)[1]
#   classes=rep(0,ntest)
#   if(ntest==ntrain) {     
#     for(i in 1:ntest) { 
#       tempo=order(gower.dist(valid[i,-p],train[-i,-p]))[1:k]
#       classes[i]=moda(train[tempo,p])[1]
#     }
#  } else {
#     for(i in 1:ntest){ 
#       tempo=order(StatMatch::gower.dist(valid[i,-p],train[,-p]))[1:k] 
#       classes[i]=moda(train[tempo,p])[1]}
#     }
# classes
# }
# 
# classification_errors = sapply(ks,function(k) {
#   pred.knn <- knngow_func(train_data,valid_data,k)
#   fit <- fitted(pred.knn)
#   mean(valid_data[,12] != fit)   #I think this is the accuracy, but it should be the classification variables
# })

####################################### NOT ABLE TO DOWNLOAD dprep EITHER

#Choose the model that has the lowest classification error, use this K
k_optimal = which.min(classification_errors)   #The best k is 7

#Plot errors as a function of k
plot(ks, classification_errors, type="o", pch = 16, ylim = c(0, 1), col = co[2],
     xlab = "Number of neighbors", ylab="Misclassification error")

pred.knn.m1 <- kknn(formula = formula(train_data_y~.), train = train_data, test = test_data, k = k_optimal, distance = 1)

predictKNN <- predict(pred.knn.m1, test = test_data_x)

#Classification error
mean(test_data_y != predictKNN)

#Accuracy
mean(test_data_y == predictKNN)

#Confusion matrix
table(test_data_y , predictKNN)


#Find the frequency of the categories for each airline

tableKNN<- cbind(test_data_x, predictKNN)


#Barplot of the delays per Airline  
barplot(table(tableKNN$predictKNN, tableKNN$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(table(tableKNN$predictKNN, tableKNN$AIRLINE)), beside=TRUE) 
#WANT TO CHANGE THE ORDER OF THE BARS TO: None, Low, Medium, High (maintaining the colors)


```


### Linear Discriminant Analysis
   
Since we have a multiclass classification problem, another possible choice of classifier is to use the linear discriminant analysis. 
```{r , echo=TRUE}
#Fit model
train_data_lda = train_data[,]
train_data_lda $ORIGIN_AIRPORT <- NULL
train_data_lda $DESTINATION_AIRPORT <- NULL

modelLDA <-lda(formula = formula(train_data_y~.), data = train_data_lda)

predictLDA <- predict(modelLDA, test_data_x)

#Confusion matrix
table(predictLDA, test_data_y)

#Compute LDA error
mean(test_data_y != predictLDA)

#Compute LDA accuracy
mean(test_data_y == predictLDA)


#Find the best airline using the histogram
tableLDA <- cbind(test_data_x, predictLDA)

#Barplot of the delays per Airline  
barplot(table(tableLDA$predictLDA, tableLDA$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(table(tableLDA$predictLDA, tableLDA$AIRLINE)), beside=TRUE)
#Remember to adjust number of colours to number of categories in the response variable

```



# Learning/Limitations/Future work

 <!-- Imagine you are going to meet the researcher who contacted you.  Report to him/her what you have learned about the problem.  Discuss limitations of the analysis you have done and provide suggestions for future work.-->


```{r , echo=TRUE}


```

