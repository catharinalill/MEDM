R_project - MEDM

---
title: "Project MEDM"
output: html_document
        #pdf_document
        
---

<!-- Press Knit, to make a html-file of the code below. This we can use while working with the report to see how it is. Because the dataset flights in pretty large it takes some time to knit the file.. 
We don´t have to compilate the code to a pdf before we are delivering it, but if you want to you might have to download a program, maybe Latex or something, I am not quite sure. I already have it so I can compilate it to a pdf when we are done with it. 
But remember if you compilate it to a pdf-file some lines can be too long and get cutted. Then you have to go in the code and adjust it. If you need a linespace you need to have 3 space in the line above. -->

<!-- In gitkranken: 
When you have edited the code, save it usual. Then open gitkranken, and you will see a blue line with 
" x file changes in working directory" and a small box "View changes" in the above right corner. Click this one. First you have to commit what you have done, i.e. click on the Project_report.html-file on the right side and press Stage File. (And don´t stage all the other files) Then make a comment on what you have changed in the file, in the bottom right corner, and press the green box "Stage files/changes to commit". 
After commiting you first have to pull what the other have done, i.e. press "Pull". If you get "pulled successfully" down in the left corner everything is okay and you can press "Push". 
If not, then we might have some merge conflict we need to fix. 
Always remember to do all these steps
1. Commit
2. Pull
3. Push

If you have edited the file, but don´t want to save it, only download what the others have done, you can press the "Stash" instead of pull and push. 
-->

```{r setup, include=FALSE}
#Have to include the files in the same folder the Rmarkdown is in.
airlines = read.csv("airlines.csv")
airports = read.csv("airports.csv")
flights = read.csv("flights.csv")

```

   
# Introduction


# Exploratory data analysis 
```{r , echo=FALSE}
#Libraries
library(ggplot2)       #for ggplot
library(class)         #for confusion matrices
library(caret)         #for knn function
library(kknn)
library(e1071)         #for naive bayes function
library(GGally)
library(corrplot)
library(DataExplorer)
library(dplyr)
library(MASS)          #for LDA
library(nnet)          #for LDA
library(leaps)         #for Forward selection
library(colorspace)    #for plot colors
library(dplyr)         #for barplots
library(tidyverse)     #for barplots
# library(StatMatch)     #for knngow function
# library(dprep)        #for knngow function
library(broom)
library(rpart)        #for fitting tree
library(rpart.plot)   #for plotting tree
library(leaflet)      #for map plots
library(randomForest) # for randomForest
library(pROC)         #ROC curve
library(plotrix)
```

```{r , echo=TRUE}
#Plots for the original data set

  ##Pie chart for diverted/cancelled/none
  count_diverted <- sum(flights$DIVERTED==1)
  count_cancelled <- sum(flights$CANCELLED==1)
  count_scheduled <- sum(flights$DIVERTED==0 & flights$CANCELLED==0)
  
  slices <- c(count_diverted, count_cancelled, count_scheduled) 
  lbls <- c("Diverted", "Cancelled", "Scheduled")
  pct <- round(slices/sum(slices)*100, 2)
  lbls <- paste(lbls, pct) # add percents to labels 
  lbls <- paste(lbls,"%",sep="") # add % to labels 
  pie(slices,labels = lbls, col=c("chocolate1","brown4","darkolivegreen2"),   #Not very good - use Carolina's chart
     main="Percentage of flight types") 
  
  #Erase rows for cancelled or diverted flights
  flights_plot <- flights[,]
  flights_plot <- flights_plot[flights_plot$DIVERTED==0,]
  flights_plot <- flights_plot[flights_plot$CANCELLED==0,]
  
  #Create list of existent airports
  airports_list <- airports$IATA_CODE
  
  #Create list of existent airlines
  airlines_list <- airlines$IATA_CODE
  
  #Show airports with invalid IATA codes
  ghost_airports <- flights_plot[!(flights_plot$ORIGIN_AIRPORT %in% airports_list),]
  ghost_airports<- droplevels(ghost_airports,exclude = ghost_airports$ORIGIN_AIRPORT %in% airports_list)
  table(ghost_airports$MONTH) #all the flights are from october
  
  barplot(table(ghost_airports$ORIGIN_AIRPORT), main="Frequencies of accomplished ghost flights by Origin Airport",
  xlab="Origin Airport", col=c("chartreuse3"), beside=TRUE)
  
    #Erase observations for origin_airports, destination_airports which are not contained in the data frame airports and airlines which are     not contained in the data frame airlines
  flights_plot<- flights_plot[flights_plot$ORIGIN_AIRPORT %in% airports_list,]
  flights_plot<- flights_plot[flights_plot$DESTINATION_AIRPORT %in% airports_list,]
  flights_plot<- flights_plot[flights_plot$AIRLINE %in% airlines_list,]
  
  flights_plot<- droplevels(flights_plot,exclude = !(flights_plot$ORIGIN_AIRPORT %in% airports_list))
  flights_plot<- droplevels(flights_plot,exclude = !(flights_plot$DESTINATION_AIRPORT %in% airports_list))
  flights_plot<- droplevels(flights_plot,exclude = !(flights_plot$AIRLINE %in% airlines_list))
  
  
  ##Barplot of flights per month, day, day of week, airline, origin/destination airport
    #Month
    barplot(table(flights_plot$MONTH), main="Frequencies of accomplished flights by Month",
  xlab="Month", col=c("chartreuse3"), beside=TRUE)
    #Day
    barplot(table(flights_plot$DAY), main="Frequencies of accomplished flights by Day",
  xlab="Day", col=c("chartreuse3"), beside=TRUE)
    #Day of week
    barplot(table(flights_plot$DAY_OF_WEEK), main="Frequencies of accomplished flights by Day Of Week",
  xlab="Day of week", col=c("chartreuse3"), beside=TRUE)
    #Airline
    barplot(table(flights_plot$AIRLINE), main="Frequencies of accomplished flights by Airline",
  xlab="Airline", col=c("chartreuse3"), beside=TRUE)
    
    #Origin airport
     barplot(table(flights_plot$ORIGIN_AIRPORT), main="Frequencies of accomplished flights by Origin Airport",
  xlab="Origin Airport", col=c("chartreuse3"), beside=TRUE)
  
    #Destination airport
     barplot(table(flights_plot$DESTINATION_AIRPORT), main="Frequencies of accomplished flights by Destination Airport",
  xlab="Destination Airport", col=c("chartreuse3"), beside=TRUE)
  
  
  
  

```

```{r , echo=TRUE}

handled_flights <- flights[,]  


#Erase the observations for which there was no information concerning the arrival delay
handled_flights<- handled_flights[is.na(handled_flights$ARRIVAL_DELAY)==FALSE,]
#As a result, we end up with no cancelled flights, since the ones that arrived (so the arrival delay will have some value) are the ones that were not cancelled

#Change handled_flights dataframe data types to the correct ones
#Discrete variables must be considered as FACTORs
handled_flights$YEAR <- as.factor(handled_flights$YEAR)
handled_flights$MONTH <- as.factor(handled_flights$MONTH)
handled_flights$DAY <- as.factor(handled_flights$DAY)
handled_flights$DAY_OF_WEEK <- as.factor(handled_flights$DAY_OF_WEEK)
handled_flights$FLIGHT_NUMBER <- as.factor(handled_flights$FLIGHT_NUMBER)

handled_flights$SCHEDULED_DEPARTURE <- as.numeric(handled_flights$SCHEDULED_DEPARTURE)
mean(handled_flights$SCHEDULED_DEPARTURE)
median(handled_flights$SCHEDULED_DEPARTURE)
sd(handled_flights$SCHEDULED_DEPARTURE)

handled_flights$DEPARTURE_TIME <- as.numeric(handled_flights$DEPARTURE_TIME)
mean(handled_flights$DEPARTURE_TIME)
median(handled_flights$DEPARTURE_TIME)
sd(handled_flights$DEPARTURE_TIME)

handled_flights$DEPARTURE_DELAY <- as.numeric(handled_flights$DEPARTURE_DELAY)
mean(handled_flights$DEPARTURE_DELAY)
median(handled_flights$DEPARTURE_DELAY)
sd(handled_flights$DEPARTURE_DELAY)

handled_flights$TAXI_OUT <- as.numeric(handled_flights$TAXI_OUT)
mean(handled_flights$TAXI_OUT)
median(handled_flights$TAXI_OUT)
sd(handled_flights$TAXI_OUT)

handled_flights$WHEELS_OFF <- as.numeric(handled_flights$WHEELS_OFF)
mean(handled_flights$WHEELS_OFF)
median(handled_flights$WHEELS_OFF)
sd(handled_flights$WHEELS_OFF)

handled_flights$SCHEDULED_TIME <- as.numeric(handled_flights$SCHEDULED_TIME)
mean(handled_flights$SCHEDULED_TIME)
median(handled_flights$SCHEDULED_TIME)
sd(handled_flights$SCHEDULED_TIME)

handled_flights$ELAPSED_TIME <- as.numeric(handled_flights$ELAPSED_TIME)
mean(handled_flights$ELAPSED_TIME)
median(handled_flights$ELAPSED_TIME)
sd(handled_flights$ELAPSED_TIME)

handled_flights$AIR_TIME <- as.numeric(handled_flights$AIR_TIME)
mean(handled_flights$AIR_TIME)
median(handled_flights$AIR_TIME)
sd(handled_flights$AIR_TIME)

handled_flights$DISTANCE <- as.numeric(handled_flights$DISTANCE)
mean(handled_flights$DISTANCE)
median(handled_flights$DISTANCE)
sd(handled_flights$DISTANCE)

handled_flights$WHEELS_ON <- as.numeric(handled_flights$WHEELS_ON)
mean(handled_flights$WHEELS_ON)
median(handled_flights$WHEELS_ON)
sd(handled_flights$WHEELS_ON)

handled_flights$TAXI_IN <- as.numeric(handled_flights$TAXI_IN)
mean(handled_flights$TAXI_IN)
median(handled_flights$TAXI_IN)
sd(handled_flights$TAXI_IN)

handled_flights$SCHEDULED_ARRIVAL <- as.numeric(handled_flights$SCHEDULED_ARRIVAL)
mean(handled_flights$SCHEDULED_ARRIVAL)
median(handled_flights$SCHEDULED_ARRIVAL)
sd(handled_flights$SCHEDULED_ARRIVAL)

handled_flights$ARRIVAL_TIME <- as.numeric(handled_flights$ARRIVAL_TIME)
mean(handled_flights$ARRIVAL_TIME)
median(handled_flights$ARRIVAL_TIME)
sd(handled_flights$ARRIVAL_TIME)

handled_flights$ARRIVAL_DELAY <- as.numeric(handled_flights$ARRIVAL_DELAY)
mean(handled_flights$ARRIVAL_DELAY)
median(handled_flights$ARRIVAL_DELAY)
sd(handled_flights$ARRIVAL_DELAY)

handled_flights$DIVERTED <- as.factor(handled_flights$DIVERTED)
handled_flights$CANCELLED <- as.factor(handled_flights$CANCELLED)



#Remove columns YEAR (2015 for all observations), CANCELLATION_REASON (since we are now dealing with flights that were not canceled), CANCELLED (will have 0's since these are the flights that were not cancelled) and DIVERTED (will have 1's for observations where ARRIVAL DELAY = NA,so we may remove this column)
handled_flights$YEAR <- NULL
handled_flights$DIVERTED <- NULL
handled_flights$CANCELLED <- NULL
handled_flights$CANCELLATION_REASON <- NULL

#Create list of existent airports
airports_list <- airports$IATA_CODE

#Create list of existent airlines
airlines_list <- airlines$IATA_CODE

#Erase observations for origin_airports, destination_airports which are not contained in the data frame airports and airlines which are not contained in the data frame airlines
handled_flights<- handled_flights[handled_flights$ORIGIN_AIRPORT %in% airports_list,]
handled_flights<- handled_flights[handled_flights$DESTINATION_AIRPORT %in% airports_list,]
handled_flights<- handled_flights[handled_flights$AIRLINE %in% airlines_list,]

handled_flights<- droplevels(handled_flights,exclude = !(handled_flights$ORIGIN_AIRPORT %in% airports_list))
handled_flights<- droplevels(handled_flights,exclude = !(handled_flights$DESTINATION_AIRPORT %in% airports_list))
handled_flights<- droplevels(handled_flights,exclude = !(handled_flights$AIRLINE %in% airlines_list))

```


## Response variable

```{r , echo=TRUE}
set.seed(0)
flights_small <- sample_n(handled_flights, 30000)     

#CONSIDER 4 CATEGORIES FOR RESPONSE
#To define the degree of delay, we consider the median and mean value, for example, considering only the values of ARRIVAL_DELAY > 0, which represent delays
#median(handled_flights$ARRIVAL_DELAY[handled_flights$ARRIVAL_DELAY>0]) #mean = 33.56 median = 15  
#mean(handled_flights$ARRIVAL_DELAY[handled_flights$ARRIVAL_DELAY>0])

#flights_small$DELAY <- as.factor( ifelse(flights_small$ARRIVAL_DELAY < 1,flights_small$DELAY <- "None", ifelse(flights_small$ARRIVAL_DELAY <16,flights_small$DELAY <- "Low", ifelse(flights_small$ARRIVAL_DELAY <34,flights_small$DELAY <- "Medium", flights_small$DELAY <- "High"))) )


#Define 2 categories for the response variable(None, Delayed) 
flights_small$DELAY <- as.factor( ifelse(flights_small$ARRIVAL_DELAY < 1,flights_small$DELAY <- "None", flights_small$DELAY <- "Delayed"))


#Check response variable categories distribution in flights_small
counts_nodelay <- as.matrix(table(flights_small$DELAY=="None")) #The categories are not balanced - chose "manually" the observations so we get what desired, compromising the airline balance?
counts_nodelay <- counts_nodelay/colSums(counts_nodelay)

#Why we chose to remove Flight number and tail number
#plot_bar(flights_small)



#Since our objective is to predict the delay of a flight, we might walk a mile in someone else's shoes, this time, in the shoes of someone who is about to take a flight.
#So, we must give to the classifier, only the variables corresponding to subjects known a priori: scheduled departure, etc.

#plot_missing(flights_small)

#Maintain a priori columns and remove a posteriori columns
flights_to_predict <- flights_small[,]
flights_to_predict$DEPARTURE_TIME <- NULL
flights_to_predict$DEPARTURE_DELAY <- NULL
flights_to_predict$TAXI_OUT <- NULL                             
flights_to_predict$WHEELS_OFF <- NULL
flights_to_predict$ELAPSED_TIME <- NULL
flights_to_predict$AIR_TIME <- NULL
flights_to_predict$DISTANCE <- NULL    
flights_to_predict$WHEELS_ON <- NULL
flights_to_predict$TAXI_IN <- NULL
flights_to_predict$ARRIVAL_TIME <- NULL
flights_to_predict$ARRIVAL_DELAY <- NULL
flights_to_predict$AIR_SYSTEM_DELAY <- NULL
flights_to_predict$SECURITY_DELAY <- NULL
flights_to_predict$AIRLINE_DELAY <- NULL
flights_to_predict$LATE_AIRCRAFT_DELAY <- NULL
flights_to_predict$WEATHER_DELAY <- NULL

#Remove flight number and tail number variables since they have various levels - show that there is no influence on the categories (PLots, Histograms, etc)
flights_to_predict$FLIGHT_NUMBER <- NULL
flights_to_predict$TAIL_NUMBER <- NULL

#Separate data into the 4 categories and report results
#nodelay <- flights_to_predict[flights_to_predict$DELAY=="None",]
#lowdelay <- flights_to_predict[flights_to_predict$DELAY=='Low',]
#mediumdelay <- flights_to_predict[flights_to_predict$DELAY=='Medium',]
#highdelay <- flights_to_predict[flights_to_predict$DELAY=='High',]

# create_report(nodelay, output_file = 'nodelay.html')
# create_report(lowdelay, output_file = 'lowdelay.html')
# create_report(mediumdelay, output_file = 'mediumdelay.html')
# create_report(highdelay, output_file = 'highdelay.html')

#Temporary remove this variables 
# flights_to_predict$MONTH <- NULL
# flights_to_predict$DAY <- NULL
# flights_to_predict$DAY_OF_WEEK <- NULL
# flights_to_predict$FLIGHT_NUMBER <- NULL
# flights_to_predict$TAIL_NUMBER <- NULL
# flights_to_predict$ORIGIN_AIRPORT <- NULL
# flights_to_predict$DESTINATION_AIRPORT <- NULL
# flights_to_predict$SCHEDULED_DEPARTURE <- NULL
# flights_to_predict$SCHEDULED_ARRIVAL <- NULL
# flights_to_predict$SCHEDULED_TIME <- NULL
# flights_to_predict$AIRLINE <- NULL

```

## Exploratory data analysis Plots and Graphs and Histograms
```{r , echo=TRUE}
#FOR handled_flights (can be seen as the "original" data set, since it did not suffer undersampling)

#Number of delayed and not delayed flights
handled_flights$DELAY <- as.factor( ifelse(handled_flights$ARRIVAL_DELAY < 1,handled_flights$DELAY <- "None", handled_flights$DELAY <- "Delayed"))

handled_flights_delayed <- dim(handled_flights[handled_flights$DELAY=='Delayed',])[1]
handled_flights_notdelayed <- dim(handled_flights[handled_flights$DELAY=='None',])[1]

#Histogram with Number of delayed and not delayed flights
barplot(table(handled_flights$DELAY), main="Frequencies of response variable categories - Original data set",
  xlab="Categories", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY)), beside=TRUE)

#Barplot of the delays per Month - original data set
barplot(table(handled_flights$DELAY, handled_flights$MONTH), main="Categories of delay by Month - Original data set",
  xlab="Month", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY, handled_flights$MONTH)), beside=TRUE)

#Barplot of the delays per Day - original data set
barplot(table(handled_flights$DELAY, handled_flights$DAY), main="Categories of delay by Day - Original data set",
  xlab="Day", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY, handled_flights$DAY)), beside=TRUE)

#Barplot of the delays per Day Of Week - original data set
barplot(table(handled_flights$DELAY, handled_flights$DAY_OF_WEEK), main="Categories of delay by Day Of Week - Original data set",
  xlab="Day Of Week", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY, handled_flights$DAY_OF_WEEK)), beside=TRUE)

#Barplot of the delays per Airline - original data set
barplot(table(handled_flights$DELAY, handled_flights$AIRLINE), main="Categories of delay by Airline - Original data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(handled_flights$DELAY, handled_flights$AIRLINE)), beside=TRUE)



#FOR flights_to_predict

#Histogram with Number of delayed and not delayed flights
barplot(table(flights_to_predict$DELAY), main="Frequencies of response variable categories - Final data set",
  xlab="Categories", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY)), beside=TRUE)

#Barplot of the delays per Month - final data set
barplot(table(flights_to_predict$DELAY, flights_to_predict$MONTH), main="Categories of delay by Month - Final data set",
  xlab="Month", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY, flights_to_predict$MONTH)), beside=TRUE)

#Barplot of the delays per Day - final data set
barplot(table(flights_to_predict$DELAY, flights_to_predict$DAY), main="Categories of delay by Day - Final data set",
  xlab="Day", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY, flights_to_predict$DAY)), beside=TRUE)

#Barplot of the delays per Day Of Week - final data set
barplot(table(flights_to_predict$DELAY, flights_to_predict$DAY_OF_WEEK), main="Categories of delay by Day Of Week - Final data set",
  xlab="Day of Week", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY, flights_to_predict$DAY_OF_WEEK)), beside=TRUE)

#Barplot of the delays per Airline - final data set
barplot(table(flights_to_predict$DELAY, flights_to_predict$AIRLINE), main="Categories of delay by Airline - Final data set",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(flights_to_predict$DELAY, flights_to_predict$AIRLINE)), beside=TRUE)


```


## Final data set

```{r , echo=TRUE}
#Find the percentages of each airline
n = dim(handled_flights)[1]
counts <- table(handled_flights$AIRLINE)
percentage <- counts/n
percentage

#Find the percentages of each airline in small dataset
n2 = dim(flights_small)[1]
counts2 <- table(flights_small$AIRLINE)
percentage2 <- counts2/n2
percentage2
#Comment that we see that these percentages is the same so this is okay to do

#Count by airline how many flights are delayed in handled_flights
handled_flightsdelayed<- handled_flights[handled_flights$ARRIVAL_DELAY>0,]
counts3 <- table(handled_flightsdelayed$AIRLINE)
percentdelayedbyairline <- counts3/counts

#Count by airline how many flights are delayed in flights_small
flights_smalldelayed<- flights_small[flights_small$ARRIVAL_DELAY>0,]
counts4 <- table(flights_smalldelayed$AIRLINE)
percentdelayedbyairline2 <- counts4/counts2

percentdelayedbyairline
percentdelayedbyairline2 

#Check if the variable distributions are maintained after sampling- NO! BECAUSE WE MUST MANTAIN THE BALANCE BETWEEN CLASSES
# create_report(flights_small, output_file = 'report_flights_small.html')
# create_report(handled_flights, output_file = 'report_handled_flights.html')


#Check correlation
#plot_correlation((flights_to_predict[, 1:10]), type = "continuous")
#Maybe comment in the report that this seems okay!
#WE CAN SHOW THIS PLOT JUST FOR THE 3 CONTINUOUS VARIABLES



```

   

# PART 2: SOLVE CLASSIFICATION PROBLEM

 <!-- Solve your classification problem.  Consider several classification methods and discuss  how  can  they  contribute  for  the  solution  of  your  problem.   Include in your discussion topics such as the options that you have made in building each  classifier;  interpretation  of  results;  validation  of  the  methods  used  and possible assumptions;  advantages and disadvantages of each alternative;  etc. Have  in  mind  that  some  of  the  explanatory  variables  may  be  irrelevant  to the  classification problem and that  you may need to  do  some  preprocessing methodologies of your data set e.g.  dimensionality reduction techniques.-->

## Hold Out Method
```{r , echo=TRUE}
#Split sample in train (70%), validation (15%) and test (15%)
#Train: create the model
#Validation: choose parameters for classifiers
#Test: evaluate the fit of the classifier and compare it with the others

set.seed(0)   # To fix the random process at splitting data
num_obs <- dim(flights_to_predict)[1]
index_list <- c(1:num_obs)
train_index <- sample(index_list, num_obs*0.7)
test_valid_index <- setdiff(index_list, train_index)
test_index <- sample(test_valid_index, length(test_valid_index)*0.5)
valid_index <- setdiff(test_valid_index, test_index)

train_data <- flights_to_predict[train_index,]
train_data_x <- flights_to_predict[train_index,]
train_data_x$DELAY <- NULL 
train_data_y <- (flights_to_predict[train_index,])$DELAY


valid_data <- flights_to_predict[valid_index,]
valid_data_x <- flights_to_predict[valid_index,]
valid_data_x$DELAY <- NULL 
valid_data_y <- (flights_to_predict[valid_index,])$DELAY

#Check percentages of delay and none in valid set
percent <- table(valid_data$DELAY)/dim(valid_data)[1]


test_data <- flights_to_predict[test_index,]
test_data_x <- flights_to_predict[test_index,]
test_data_x$DELAY <- NULL 
test_data_y <- (flights_to_predict[test_index,])$DELAY

#Checking distribution in original and partitioned data  
# prop.table(table(train_data_y)) * 100 # at training set 
# prop.table(table(test_data_y)) * 100  # at testing set
# prop.table(table(valid_data_y)) * 100  # at validation set
# prop.table(table(flights_to_predict$DELAY)) * 100  # at original dataset
#THIS SEEMS FINE!


```

## Naive Bayes method

```{r , echo=TRUE}
set.seed(0)

#Use validation set to determine if is better to use Laplace or not
#No Laplace
modelNBNoLap <- naiveBayes(formula = formula(train_data_y~.), data = train_data, laplace = 0)
predictNBNoLap <- predict(modelNBNoLap, valid_data_x)

#Confusion matrix
table(predictNBNoLap, valid_data_y)
#               valid_data_y
# predictNBNoLap Delayed None
#        Delayed     464  547
#        None       1209 2280

#Compute NB error
mean(valid_data_y != predictNBNoLap) #0.3902222

#Compute NB accuracy
mean(valid_data_y == predictNBNoLap) #0.6097778

posPredNBNoLap <- posPredValue(predictNBNoLap, valid_data_y, positive = "None") #0.6534824

#With Laplace
modelNBLap <- naiveBayes(formula = formula(train_data_y~.), data = train_data, laplace = 1)
predictNBLap <- predict(modelNBLap, valid_data_x)

#Confusion matrix
table(predictNBLap, valid_data_y)
#             valid_data_y               
# predictNBLap Delayed None
#      Delayed     414  473
#      None       1259 2354

#  -->
#             valid_data_y
# predictNBLap Delayed None
#      Delayed     438  505
#      None       1235 2322

#Compute NB error
mean(valid_data_y != predictNBLap) #0.3848889   -> 0.3866667

#Compute NB accuracy
mean(valid_data_y == predictNBLap) #0.6151111  -> 0.6133333

posPredNBLap <- posPredValue(predictNBLap, valid_data_y, positive = "None") #0.6515361  -> 0.6527973


#SO, WE USE LAPLACE

predictNB <- predict(modelNBLap, test_data_x)

#Confusion matrix
table(predictNB, test_data_y)
#          test_data_y
# predictNB Delayed None
#   Delayed     417  444
#   None       1313 2326

# -->
#          test_data_y
# predictNB Delayed None
#   Delayed     448  470
#   None       1282 2300

#Compute NB error
mean(test_data_y != predictNB) #0.3904444  -> 0.3893333

#Compute NB accuracy
mean(test_data_y == predictNB) #0.6095556 -> 0.6106667


#SENSITIVE MEASURES

#Sensitivity: proportion of positive results out of the number of samples which were actually positive.
senseNB <- sensitivity(predictNB, test_data_y, positive = "None")
#Specificity: proportion of negative results out of the number of samples which were actually negative.
specNB <- specificity(predictNB, test_data_y, negative = "Delayed")

senseNB #0.8303249
specNB #0.2589595

#Precision/Positive Predictive Value: percent of predicted positives that are actually positive.
posPredNB <- posPredValue(predictNB, test_data_y, positive = "None")
#Negative Predictive Value: percent of negative positives that are actually negative.
negPredNB <- negPredValue(predictNB, test_data_y, negative = "Delayed")

posPredNB #0.6420994
negPredNB #0.4880174



#BACKWARD PROBLEM: FIND THE AIRLINE

#Find the best airline using the histogram
tableNB <- cbind(test_data_x, predictNB)


#Barplot of the delays per Airline  
barplot(table(tableNB$predictNB, tableNB$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topleft"),
  legend = rownames(table(tableNB$predictNB, tableNB$AIRLINE)), beside=TRUE)

#Get the percentages of delayed and not delayed for Airline
countdelayNB <- as.matrix(table(tableNB$predictNB, tableNB$AIRLINE))
countdelayNB <- sweep(countdelayNB, 2, colSums(countdelayNB), FUN = '/')

colnames(countdelayNB) = c("AA","AS", "B6","DL","EV","F9","HA","MQ","NK","OO","UA","US","VX","WN") 
rownames(countdelayNB) = c("Delayed", "None")

#Get the most and least delayed Airline
mostdelayedNB <- colnames(countdelayNB)[which.is.max(countdelayNB[1,])] 
mostdelayedNB      #Airline which had the higher value of delay

leastdelayedNB <- colnames(countdelayNB)[which.is.max(countdelayNB[2,])] 
leastdelayedNB      #Airline which had the lower value of delay

#See sorted list of delayed and non delayed
mostdelayed_sortNB <- sort(countdelayNB[1,], decreasing = TRUE) #Higher percentage means high delay
leastdelayed_sortNB <- sort(countdelayNB[2,], decreasing = TRUE) #Higher percentage means low delay

mostdelayed_sortNB

#Barplot of the delays (percentge) per Airline  
barplot(countdelayNB, main="Categories of delay by Airline - Percentage",
  xlab="Airlines", col=c("firebrick", "chartreuse3"), args.legend = list(x="topright"),
  legend = rownames(table(tableNB$predictNB, tableNB$AIRLINE)), beside=TRUE)
```


## Decision Tree
```{r , echo=TRUE}
set.seed(10)
#Use validation set to choose the splitting criterion (information or gini)
# MODEL FITTING

modelTREEgini <- rpart(formula = formula(train_data_y~.), data = train_data_x, method = "class", parms = list(split ="gini")) 

modelTREEinf <- rpart(formula = formula(train_data_y~.), data = train_data_x, method = "class", parms = list(split ="information")) 

#Compute posPredValue using gini, for the validation set
predictTREEgini <- predict(modelTREEgini, valid_data, type = "class")

posPredTREEgini <- posPredValue(predictTREEgini, valid_data_y, positive = "None")     
accTREEgini <- mean(valid_data_y == predictTREEgini)
table(predictTREEgini, valid_data_y)

#Compute posPredValue using information, for the validation set
predictTREEinf <- predict(modelTREEinf, valid_data, type = "class")

posPredTREEinf <- posPredValue(predictTREEinf, valid_data_y, positive = "None")
accTREEinf <- mean(valid_data_y == predictTREEinf)
table(predictTREEinf, valid_data_y)

#WE USE GINI BECAUSE IT WAS THE FIRST ONE COMPUTED - IT IS INDIFERENT SINCE THE RESULTS ARE EQUAL FOR BOTH

summary(modelTREEgini)
rpart.plot(modelTREEgini)

predictTREE <- predict(modelTREEgini, test_data, type = "class")

#Confusion matrix
table(predictTREE, test_data_y)

#            test_data_y
# predictTREE Delayed None
#     Delayed     221  243
#     None       1509 2527

#Compute the TREE error
mean(test_data_y != predictTREE) #0.3893333

#Compute TREE accuracy
mean(test_data_y == predictTREE) #0.6106667

#####################################################################
#Maybe try pruning (looked at her example from class today)
printcp(modelTREEgini)
bestcp <- modelTREEgini$cptable[which.min(modelTREEgini$cptable[,"xerror"]), "CP"]
plotcp(modelTREEgini)

#Prune the tree - It is not good, but we can show this in the report
modelTREEgini_pruned <- prune(modelTREEgini, cp = bestcp)
predictTREEgini_pruned <- predict(modelTREEgini_pruned, test_data, type = "class")
table(predictTREEgini_pruned, test_data_y)

#                       test_data_y
# predictTREEgini_pruned Delayed None
#                Delayed       0    0
#                None       1730 2770

#####################################################################

#SENSITIVE MEASURES

#Sensitivity: proportion of positive results out of the number of samples which were actually positive.
senseTREE <- sensitivity(predictTREE, test_data_y, positive = "None")
#Specificity: proportion of negative results out of the number of samples which were actually negative.
specTREE <- specificity(predictTREE, test_data_y, negative = "Delayed")

senseTREE #0.9122744
specTREE #0.1277457

#Precision/Positive Predictive Value: percent of predicted positives that are actually positive.
posPredTREE <- posPredValue(predictTREE, test_data_y, positive = "None")
#Negative Predictive Value: percent of negative positives that are actually negative.
negPredTREE <- negPredValue(predictTREE, test_data_y, negative = "Delayed")

posPredTREE #0.626115
negPredTREE #0.4762931

#NOTE: when there are no positive/negative results, Nan is returned. In this case, there are no negatives, which I do not understand


#BACKWARD PROBLEM: FIND THE AIRLINE

#Find the best airline using the histogram
tableTREE <- cbind(test_data_x, predictTREE)

#Barplot of the delays per Airline  
barplot(table(tableTREE$predictTREE, tableTREE$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "blue"), args.legend = list(x="topleft"),
  legend = rownames(table(tableTREE$predictTREE, tableTREE$AIRLINE)), beside=TRUE)


#Get the percentages of delayed and not delayed for Airline
countdelayTREE <- as.matrix(table(tableTREE$predictTREE, tableTREE$AIRLINE))
countdelayTREE <- sweep(countdelayTREE, 2, colSums(countdelayTREE), FUN = '/')
colnames(countdelayTREE) = c("AA","AS", "B6","DL","EV","F9","HA","MQ","NK","OO","UA","US","VX","WN") 
rownames(countdelayTREE) = c("Delayed", "None")

#Get the most delayed Airline
mostdelayedTREE <- colnames(countdelayTREE)[which.is.max(countdelayTREE[1,])] #Airline which had the higher value of delay
leastdelayedTREE <- colnames(countdelayTREE)[which.is.max(countdelayTREE[2,])] #Airline which had the lower value of delay

#See sorted list of delayed and non delayed
mostdelayed_sortTREE <- sort(countdelayTREE[1,], decreasing = TRUE) #Higher percentage means high delay
leastdelayed_sortTREE <- sort(countdelayTREE[2,], decreasing = TRUE) #Higher percentage means low delay

mostdelayedTREE
leastdelayedTREE
```
One advantage with the classification tree is that they are more flexible than linear methods. 

## Random Forest

```{r, echo=TRUE}

train_data_x_rf = train_data_x[,]
train_data_x_rf$ORIGIN_AIRPORT <- NULL
train_data_x_rf$DESTINATION_AIRPORT <- NULL
train_data_x_rf$DAY<- NULL

test_data_rf = test_data[,]
test_data_rf$ORIGIN_AIRPORT <- NULL
test_data_rf$DESTINATION_AIRPORT <- NULL
test_data_rf$DAY <- NULL

modelRF = randomForest(train_data_y~., data = train_data_x, mtry = 3, importance = TRUE)
#Cannot handle variables with more than 53 categories... so we had to try to reduce the data set just to see if this will work


predictRF <- predict(modelRF, test_data_rf)

#varImpPlot(modelRF)

#Confusion matrix
table(predictRF, test_data_y)

#Compute the TREE error
mean(test_data_y != predictRF)

#Compute TREE accuracy
mean(test_data_y == predictRF) 

#rocTREE = roc(test_data_y, as.numeric(predictTREE), legacy.axes = TRUE, auc = TRUE, plot = TRUE)


#BACKWARD PROBLEM: FIND THE AIRLINE
  
#Find the best airline using the histogram
tableRF <- cbind(test_data_rf, predictRF)

#Barplot of the delays per Airline  
barplot(table(tableRF$predictRF, tableRF$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "blue"), args.legend = list(x="topleft"),
  legend = rownames(table(tableRF$predictRF, tableRF$AIRLINE)), beside=TRUE)

#Get the percentages of delayed and not delayed for Airline
countdelayRF <- as.matrix(table(tableRF$predictRF, tableRF$AIRLINE))
countdelayRF <- sweep(countdelayRF, 2, colSums(countdelayRF), FUN = '/')

colnames(countdelayRF) = c("AA","AS", "B6","DL","EV","F9","HA","MQ","NK","OO","UA","US","VX","WN") 
rownames(countdelayRF) = c("Delayed", "None")

#Get the most and least delayed Airline
mostdelayedRF <- colnames(countdelayRF)[which.is.max(countdelayRF[1,])] 
mostdelayedRF      #Airline which had the higher value of delay

leastdelayedRF <- colnames(countdelayRF)[which.is.max(countdelayRF[2,])] 
leastdelayedRF      #Airline which had the lower value of delay

#See sorted list of delayed and non delayed
mostdelayed_sortRF <- sort(countdelayRF[1,], decreasing = TRUE) #Higher percentage means high delay
leastdelayed_sortRF <- sort(countdelayRF[2,], decreasing = TRUE) #Higher percentage means low delay

mostdelayed_sortRF
leastdelayed_sortRF
```

## Support Vector Classifier
```{r, echo=TRUE}
library(e1071)
modelSVM = svm(train_data_y~., data = train_data_x, kernel = "linear", cost = 10)

predictSVM <- predict(modelSVM, test_data)

#Confusion matrix
table(predictSVM, test_data_y)

#Compute the TREE error
mean(test_data_y != predictSVM)

#Compute TREE accuracy
mean(test_data_y == predictSVM) 
  
#Find the best airline using the histogram
tableSVM <- cbind(test_data_x, predictSVM)


#Barplot of the delays per Airline  
barplot(table(tableSVM$predictSVM, tableSVM$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "blue"), args.legend = list(x="topleft"),
  legend = rownames(table(tableSVM$predictSVM, tableSVM$AIRLINE)), beside=TRUE)

#Get the percentages of delayed and not delayed for Airline
countdelaySVM <- as.matrix(table(tableSVM$predictSVM, tableSVM$AIRLINE))
countdelaySVM <- sweep(countdelaySVM, 2, colSums(countdelaySVM), FUN = '/')

colnames(countdelaySVM) = c("AA","AS", "B6","DL","EV","F9","HA","MQ","NK","OO","UA","US","VX","WN") 
rownames(countdelaySVM) = c("Delayed", "None")

#Get the most and least delayed Airline
mostdelayedSVM <- colnames(countdelaySVM)[which.is.max(countdelaySVM[1,])] 
mostdelayedSVM      #Airline which had the higher value of delay

leastdelayedSVM <- colnames(countdelaySVM)[which.is.max(countdelaySVM[2,])] 
leastdelayedSVM      #Airline which had the lower value of delay

#See sorted list of delayed and non delayed
mostdelayed_sortSVM <- sort(countdelaySVM[1,], decreasing = TRUE) #Higher percentage means high delay
leastdelayed_sortSVM <- sort(countdelaySVM[2,], decreasing = TRUE) #Higher percentage means low delay

mostdelayed_sortSVM
leastdelayed_sortSVM
```

## Logistic Regression - problems with the presence of categories for all variables in train and test sets
```{r, echo=TRUE}
train_data_logreg = train_data[,]
train_data_logreg$ORIGIN_AIRPORT <- NULL
train_data_logreg$DESTINATION_AIRPORT <- NULL
train_data_logreg$MONTH <- NULL
train_data_logreg$DAY <- NULL
train_data_logreg$DAY_OF_WEEK <- NULL

test_data_logreg = test_data[,]
test_data_logreg$ORIGIN_AIRPORT <- NULL
test_data_logreg$DESTINATION_AIRPORT <- NULL
test_data_logreg$MONTH <- NULL
test_data_logreg$DAY <- NULL
test_data_logreg$DAY_OF_WEEK <- NULL

delay = vector(length = length(train_data_y))
delay = ifelse(train_data_y == "None",0,1)
#We use family = binomial since our response is of type factor

#Fit model
modelLR <- glm(formula = formula(delay~.), data = train_data, family = "binomial", control = list(maxit = 5000))

coef(modelLR)
modelLR

predictLR <- predict(modelLR, test_data_logreg)
predictLR

# n = obs
#round(n*0.15)

DELAY <- vector(mode = "character",length = 1500)
for (i in 1:1500) {
DELAY[i] = ifelse(predictLR[i] < 30, "Delayed", "None")
}

#Confusion matrix
table(DELAY, test_data_y)

#Compute the TREE error
mean(test_data_y != predictLR)

#Compute TREE accuracy
mean(test_data_y == predictLR)


#Find the best airline using the histogram
tableLR <- cbind(test_data_x, predictLR)

#Barplot of the delays per Airline  
barplot(table(tableLR$predictLR, tableLR$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(table(tableLR$predictLR, tableLR$AIRLINE)), beside=TRUE)
#Remember to adjust number of colours to number of categories in the response variable

```


## Probably not gonna be used

### Multinomial Logistic regression - Should be considered, for instance, if we mantain 4 categories

<!--We use Multinomial logistic regression since we have 4 categories: None, Low, Medium, High-->
   
```{r , echo=TRUE}
#Fit model
modelMLR <- multinom(formula = formula(train_data_y~.), data= train_data)
predictMLR <- predict(modelMLR, test_data_x)

#Confusion matrix
table(predictMLR, test_data_y)

#Compute MLR error
mean(test_data_y != predictMLR)

#Compute MLR accuracy
mean(test_data_y == predictMLR)


#Find the best airline using the histogram
tableMLR <- cbind(test_data_x, predictMLR)

#Barplot of the delays per Airline  
barplot(table(tableMLR$predictMLR, tableMLR$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(table(tableMLR$predictMLR, tableMLR$AIRLINE)), beside=TRUE)
#Remember to adjust number of colours to number of categories in the response variable

```

## KNN - not able to consider factor and continuous variables simultaneously

```{r , echo=FALSE}
#We will use Hold Out Method to partition the sample in train, validation and test data

co = rainbow_hcl(3)

#Make model
ks = 1:10 #Choose K from 1 to 10
classification_errors = sapply(ks,function(k) {
  pred.knn <- kknn(formula = formula(train_data_y~.), train = train_data, test = valid_data, k = k, distance = 1)
  fit <- fitted(pred.knn)
  mean(valid_data_y != fit)   #I think this is the accuracy, but it should be the classification variables
})

####ANother attempt at calculating class_error############################ THINK WE DO NOT NEED THIS

# knngow_func <- function (train,valid,k) {
#   p=dim(train)[2]
#   ntest=dim(valid)[1]
#   ntrain=dim(train)[1]
#   classes=rep(0,ntest)
#   if(ntest==ntrain) {     
#     for(i in 1:ntest) { 
#       tempo=order(gower.dist(valid[i,-p],train[-i,-p]))[1:k]
#       classes[i]=moda(train[tempo,p])[1]
#     }
#  } else {
#     for(i in 1:ntest){ 
#       tempo=order(StatMatch::gower.dist(valid[i,-p],train[,-p]))[1:k] 
#       classes[i]=moda(train[tempo,p])[1]}
#     }
# classes
# }
# 
# classification_errors = sapply(ks,function(k) {
#   pred.knn <- knngow_func(train_data,valid_data,k)
#   fit <- fitted(pred.knn)
#   mean(valid_data[,12] != fit)   #I think this is the accuracy, but it should be the classification variables
# })

####################################### NOT ABLE TO DOWNLOAD dprep EITHER

#Choose the model that has the lowest classification error, use this K
k_optimal = which.min(classification_errors)   #The best k is 7

#Plot errors as a function of k
plot(ks, classification_errors, type="o", pch = 16, ylim = c(0, 1), col = co[2],
     xlab = "Number of neighbors", ylab="Misclassification error")

pred.knn.m1 <- kknn(formula = formula(train_data_y~.), train = train_data, test = test_data, k = k_optimal, distance = 1)

predictKNN <- predict(pred.knn.m1, test = test_data_x)

#Classification error
mean(test_data_y != predictKNN)

#Accuracy
mean(test_data_y == predictKNN)

#Confusion matrix
table(test_data_y , predictKNN)


#Find the frequency of the categories for each airline

tableKNN<- cbind(test_data_x, predictKNN)


#Barplot of the delays per Airline  
barplot(table(tableKNN$predictKNN, tableKNN$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(table(tableKNN$predictKNN, tableKNN$AIRLINE)), beside=TRUE) 
#WANT TO CHANGE THE ORDER OF THE BARS TO: None, Low, Medium, High (maintaining the colors)


```


### Linear Discriminant Analysis
   
Since we have a multiclass classification problem, another possible choice of classifier is to use the linear discriminant analysis. 
```{r , echo=TRUE}
#Fit model
train_data_lda = train_data[,]
train_data_lda $ORIGIN_AIRPORT <- NULL
train_data_lda $DESTINATION_AIRPORT <- NULL

modelLDA <-lda(formula = formula(train_data_y~.), data = train_data_lda)

predictLDA <- predict(modelLDA, test_data_x)

#Confusion matrix
table(predictLDA, test_data_y)

#Compute LDA error
mean(test_data_y != predictLDA)

#Compute LDA accuracy
mean(test_data_y == predictLDA)


#Find the best airline using the histogram
tableLDA <- cbind(test_data_x, predictLDA)

#Barplot of the delays per Airline  
barplot(table(tableLDA$predictLDA, tableLDA$AIRLINE), main="Categories of delay by Airline",
  xlab="Airlines", col=c("red", "magenta","orange","yellow"), args.legend = list(x="topleft"),
  legend = rownames(table(tableLDA$predictLDA, tableLDA$AIRLINE)), beside=TRUE)
#Remember to adjust number of colours to number of categories in the response variable

```



# Learning/Limitations/Future work

 <!-- Imagine you are going to meet the researcher who contacted you.  Report to him/her what you have learned about the problem.  Discuss limitations of the analysis you have done and provide suggestions for future work.-->


```{r , echo=TRUE}


```

